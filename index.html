<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trena Virtual - Medição por Câmera</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Arial, sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #f0f0f0;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }
        
        .container {
            max-width: 100%;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 20px;
            padding-top: 10px;
        }
        
        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #00dbde, #fc00ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .subtitle {
            font-size: 1rem;
            opacity: 0.8;
            margin-bottom: 15px;
        }
        
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        
        .camera-container {
            position: relative;
            width: 100%;
            background-color: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            aspect-ratio: 4/3;
        }
        
        #camera-view {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .measurement-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border: 2px solid #00ff88;
            border-radius: 50%;
        }
        
        .crosshair:before, .crosshair:after {
            content: '';
            position: absolute;
            background-color: #00ff88;
        }
        
        .crosshair:before {
            width: 2px;
            height: 60px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair:after {
            width: 60px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .measurement-point {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #ff3366;
            border: 2px solid white;
            transform: translate(-50%, -50%);
            pointer-events: all;
            cursor: move;
        }
        
        .measurement-line {
            position: absolute;
            height: 2px;
            background-color: rgba(0, 255, 136, 0.7);
            transform-origin: 0 0;
            pointer-events: none;
        }
        
        .controls {
            background: rgba(30, 30, 46, 0.8);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .measurement-display {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .measurement-card {
            flex: 1;
            min-width: 150px;
            background: linear-gradient(135deg, #23234d, #1a1a3a);
            border-radius: 12px;
            padding: 15px;
            text-align: center;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.2);
        }
        
        .measurement-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00ff88;
            margin: 5px 0;
        }
        
        .measurement-label {
            font-size: 0.9rem;
            opacity: 0.8;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        
        .btn {
            flex: 1;
            min-width: 140px;
            padding: 12px 20px;
            border: none;
            border-radius: 10px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        .btn-primary {
            background: linear-gradient(90deg, #00dbde, #0093E9);
            color: white;
        }
        
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .btn-danger {
            background: linear-gradient(90deg, #FF416C, #FF4B2B);
            color: white;
        }
        
        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 7px 15px rgba(0, 0, 0, 0.3);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .btn i {
            font-size: 1.2rem;
        }
        
        .instructions {
            background: rgba(30, 30, 46, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .instructions h3 {
            color: #00dbde;
            margin-bottom: 10px;
            font-size: 1.2rem;
        }
        
        .instructions ol {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        
        .instructions li {
            margin-bottom: 8px;
            line-height: 1.5;
        }
        
        .warning {
            color: #ff9966;
            font-size: 0.9rem;
            font-style: italic;
            border-left: 3px solid #ff9966;
            padding-left: 10px;
        }
        
        footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            font-size: 0.9rem;
            opacity: 0.7;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        @media (max-width: 768px) {
            .measurement-display {
                flex-direction: column;
            }
            
            .buttons {
                flex-direction: column;
            }
            
            .btn {
                width: 100%;
            }
        }
        
        /* Animações */
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        .hidden {
            display: none;
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
</head>
<body>
    <div class="container">
        <header>
            <h1><i class="fas fa-ruler-combined"></i> TRENA VIRTUAL</h1>
            <p class="subtitle">Use a câmera do seu celular para medir distâncias e áreas</p>
        </header>
        
        <main class="main-content">
            <div class="camera-container">
                <video id="camera-view" autoplay playsinline></video>
                <div class="measurement-overlay" id="measurement-overlay">
                    <div class="crosshair"></div>
                </div>
            </div>
            
            <div class="controls">
                <div class="measurement-display">
                    <div class="measurement-card">
                        <div class="measurement-label">Distância</div>
                        <div class="measurement-value" id="distance-value">0.00</div>
                        <div class="measurement-label">metros</div>
                    </div>
                    
                    <div class="measurement-card">
                        <div class="measurement-label">Área</div>
                        <div class="measurement-value" id="area-value">0.00</div>
                        <div class="measurement-label">metros²</div>
                    </div>
                    
                    <div class="measurement-card">
                        <div class="measurement-label">Pontos</div>
                        <div class="measurement-value" id="points-value">0</div>
                        <div class="measurement-label">ativos</div>
                    </div>
                </div>
                
                <div class="buttons">
                    <button class="btn btn-primary" id="add-point-btn">
                        <i class="fas fa-plus-circle"></i> Adicionar Ponto
                    </button>
                    <button class="btn btn-secondary" id="clear-btn">
                        <i class="fas fa-trash-alt"></i> Limpar
                    </button>
                    <button class="btn btn-secondary" id="toggle-camera-btn">
                        <i class="fas fa-camera"></i> Alternar Câmera
                    </button>
                    <button class="btn btn-danger" id="reset-btn">
                        <i class="fas fa-redo"></i> Reiniciar
                    </button>
                </div>
            </div>
            
            <div class="instructions">
                <h3><i class="fas fa-info-circle"></i> Como usar:</h3>
                <ol>
                    <li>Posicione o celular paralelo ao objeto que deseja medir</li>
                    <li>Toque em "Adicionar Ponto" para marcar o início da medição</li>
                    <li>Mova o celular até o próximo ponto e toque novamente</li>
                    <li>A distância será calculada automaticamente</li>
                    <li>Para medir área, adicione pelo menos 3 pontos</li>
                </ol>
                <p class="warning">
                    <i class="fas fa-exclamation-triangle"></i> Nota: Esta é uma estimativa. Para medidas precisas, use uma trena física.
                </p>
            </div>
        </main>
        
        <footer>
            <p>Trena Virtual v1.0 | Use como referência | Desenvolvido para demonstração</p>
        </footer>
    </div>

    <script>
        // Elementos da interface
        const cameraView = document.getElementById('camera-view');
        const measurementOverlay = document.getElementById('measurement-overlay');
        const distanceValue = document.getElementById('distance-value');
        const areaValue = document.getElementById('area-value');
        const pointsValue = document.getElementById('points-value');
        const addPointBtn = document.getElementById('add-point-btn');
        const clearBtn = document.getElementById('clear-btn');
        const toggleCameraBtn = document.getElementById('toggle-camera-btn');
        const resetBtn = document.getElementById('reset-btn');
        
        // Variáveis de estado
        let stream = null;
        let isCameraOn = false;
        let isFrontCamera = false;
        let measurementPoints = [];
        let measurementLines = [];
        let pointCounter = 0;
        
        // Inicializar a câmera
        async function initCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: isFrontCamera ? "user" : "environment",
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                };
                
                stream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraView.srcObject = stream;
                isCameraOn = true;
                
                // Ajustar orientação da câmera baseado na orientação da tela
                handleOrientation();
                
            } catch (err) {
                console.error("Erro ao acessar a câmera:", err);
                alert("Não foi possível acessar a câmera. Verifique as permissões.");
            }
        }
        
        // Lidar com a orientação da tela
        function handleOrientation() {
            if (screen.orientation) {
                screen.orientation.addEventListener("change", () => {
                    // Atualizar a visualização da câmera baseado na orientação
                    setTimeout(() => {
                        cameraView.style.transform = getCameraTransform();
                    }, 300);
                });
            }
            
            window.addEventListener("orientationchange", () => {
                setTimeout(() => {
                    cameraView.style.transform = getCameraTransform();
                }, 300);
            });
        }
        
        // Obter transformação da câmera baseado na orientação
        function getCameraTransform() {
            const orientation = window.screen.orientation ? window.screen.orientation.type : screen.orientation;
            
            if (orientation.includes("portrait")) {
                return "";
            } else {
                return "scaleX(-1)";
            }
        }
        
        // Alternar entre câmeras
        async function toggleCamera() {
            if (!isCameraOn) return;
            
            // Parar a câmera atual
            stream.getTracks().forEach(track => track.stop());
            
            // Alternar entre frontal e traseira
            isFrontCamera = !isFrontCamera;
            
            // Reiniciar a câmera
            await initCamera();
        }
        
        // Adicionar ponto de medição
        function addMeasurementPoint() {
            pointCounter++;
            
            // Criar um ponto de medição
            const point = document.createElement('div');
            point.className = 'measurement-point pulse';
            point.id = `point-${pointCounter}`;
            point.dataset.index = measurementPoints.length;
            
            // Posicionar no centro da tela (onde está o retículo)
            point.style.top = '50%';
            point.style.left = '50%';
            
            // Adicionar ao overlay
            measurementOverlay.appendChild(point);
            
            // Adicionar ao array de pontos
            measurementPoints.push({
                id: pointCounter,
                element: point,
                x: 50, // Percentual da tela
                y: 50  // Percentual da tela
            });
            
            // Atualizar contador de pontos
            updatePointsCount();
            
            // Se houver pelo menos 2 pontos, criar uma linha entre eles
            if (measurementPoints.length >= 2) {
                createMeasurementLine(
                    measurementPoints[measurementPoints.length - 2],
                    measurementPoints[measurementPoints.length - 1]
                );
            }
            
            // Se houver pelo menos 3 pontos, calcular área
            if (measurementPoints.length >= 3) {
                calculateArea();
            }
            
            // Atualizar a distância total
            calculateTotalDistance();
        }
        
        // Criar linha de medição entre dois pontos
        function createMeasurementLine(pointA, pointB) {
            // Calcular distância e ângulo entre os pontos
            const dx = pointB.x - pointA.x;
            const dy = pointB.y - pointA.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;
            
            // Criar elemento de linha
            const line = document.createElement('div');
            line.className = 'measurement-line';
            line.id = `line-${pointA.id}-${pointB.id}`;
            
            // Posicionar a linha
            line.style.width = `${distance}%`;
            line.style.top = `${pointA.y}%`;
            line.style.left = `${pointA.x}%`;
            line.style.transform = `rotate(${angle}deg)`;
            
            // Adicionar ao overlay
            measurementOverlay.appendChild(line);
            
            // Adicionar ao array de linhas
            measurementLines.push(line);
            
            // Adicionar etiqueta de distância no meio da linha
            addDistanceLabel(line, pointA, pointB, distance, angle);
        }
        
        // Adicionar etiqueta de distância à linha
        function addDistanceLabel(line, pointA, pointB, distance, angle) {
            const label = document.createElement('div');
            label.className = 'distance-label';
            label.textContent = `${(distance / 10).toFixed(2)}m`;
            
            // Posicionar a etiqueta no meio da linha
            const midX = (pointA.x + pointB.x) / 2;
            const midY = (pointA.y + pointB.y) / 2;
            
            label.style.position = 'absolute';
            label.style.top = `${midY}%`;
            label.style.left = `${midX}%`;
            label.style.transform = `translate(-50%, -50%) rotate(${-angle}deg)`;
            label.style.color = '#00ff88';
            label.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
            label.style.padding = '3px 8px';
            label.style.borderRadius = '10px';
            label.style.fontSize = '14px';
            label.style.fontWeight = 'bold';
            label.style.zIndex = '100';
            
            measurementOverlay.appendChild(label);
        }
        
        // Calcular distância total
        function calculateTotalDistance() {
            if (measurementPoints.length < 2) {
                distanceValue.textContent = '0.00';
                return;
            }
            
            let totalDistance = 0;
            
            // Calcular a soma das distâncias entre todos os pontos consecutivos
            for (let i = 1; i < measurementPoints.length; i++) {
                const pointA = measurementPoints[i-1];
                const pointB = measurementPoints[i];
                
                const dx = pointB.x - pointA.x;
                const dy = pointB.y - pointA.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Converter para metros (considerando uma escala aproximada)
                // Na prática, aqui seria necessário calibrar com um objeto de referência
                totalDistance += distance / 10;
            }
            
            distanceValue.textContent = totalDistance.toFixed(2);
        }
        
        // Calcular área
        function calculateArea() {
            if (measurementPoints.length < 3) {
                areaValue.textContent = '0.00';
                return;
            }
            
            // Usar fórmula do polígono (Shoelace formula) para calcular área
            let area = 0;
            
            for (let i = 0; i < measurementPoints.length; i++) {
                const j = (i + 1) % measurementPoints.length;
                area += measurementPoints[i].x * measurementPoints[j].y;
                area -= measurementPoints[j].x * measurementPoints[i].y;
            }
            
            area = Math.abs(area / 2);
            
            // Converter para metros quadrados (escala aproximada)
            // Na prática, aqui seria necessário calibrar com um objeto de referência
            const areaInMeters = area / 100;
            
            areaValue.textContent = areaInMeters.toFixed(2);
        }
        
        // Atualizar contador de pontos
        function updatePointsCount() {
            pointsValue.textContent = measurementPoints.length;
        }
        
        // Limpar todos os pontos e linhas
        function clearMeasurements() {
            // Remover todos os pontos
            measurementPoints.forEach(point => {
                if (point.element && point.element.parentNode) {
                    point.element.parentNode.removeChild(point.element);
                }
            });
            
            // Remover todas as linhas
            measurementLines.forEach(line => {
                if (line.parentNode) {
                    line.parentNode.removeChild(line);
                }
            });
            
            // Remover todas as etiquetas de distância
            const labels = document.querySelectorAll('.distance-label');
            labels.forEach(label => {
                if (label.parentNode) {
                    label.parentNode.removeChild(label);
                }
            });
            
            // Resetar arrays
            measurementPoints = [];
            measurementLines = [];
            pointCounter = 0;
            
            // Atualizar valores na interface
            distanceValue.textContent = '0.00';
            areaValue.textContent = '0.00';
            updatePointsCount();
        }
        
        // Reiniciar completamente (câmera e medições)
        function resetAll() {
            clearMeasurements();
            
            if (isCameraOn && stream) {
                stream.getTracks().forEach(track => track.stop());
                isCameraOn = false;
            }
            
            // Reiniciar a câmera
            setTimeout(() => {
                initCamera();
            }, 500);
        }
        
        // Event Listeners
        addPointBtn.addEventListener('click', addMeasurementPoint);
        clearBtn.addEventListener('click', clearMeasurements);
        toggleCameraBtn.addEventListener('click', toggleCamera);
        resetBtn.addEventListener('click', resetAll);
        
        // Inicializar a câmera quando a página carregar
        window.addEventListener('DOMContentLoaded', initCamera);
        
        // Pausar a câmera quando a página não estiver visível
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && stream) {
                stream.getTracks().forEach(track => track.stop());
                isCameraOn = false;
            } else if (!document.hidden && !isCameraOn) {
                initCamera();
            }
        });
    </script>
</body>
</html>