<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trena AR Avan√ßada</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            touch-action: none;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: #000;
            color: white;
            height: 100vh;
            overflow: hidden;
            position: fixed;
            width: 100%;
        }
        
        /* Container principal */
        .app-container {
            height: 100vh;
            position: relative;
            overflow: hidden;
        }
        
        /* C√¢mera - ocupa toda a tela */
        .camera-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
        }
        
        #camera-view {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Overlay AR */
        .ar-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        /* Grade de profundidade */
        .depth-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.3;
            pointer-events: none;
            background: 
                linear-gradient(90deg, rgba(0,255,136,0.1) 1px, transparent 1px) 0 0 / 5% 100%,
                linear-gradient(0deg, rgba(0,255,136,0.1) 1px, transparent 1px) 0 0 / 100% 5%;
        }
        
        /* Reticulado AR */
        .ar-reticle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80px;
            height: 80px;
            z-index: 20;
        }
        
        .reticle-circle {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 30px;
            height: 30px;
            border: 3px solid #00ff88;
            border-radius: 50%;
            animation: reticlePulse 2s infinite;
        }
        
        .reticle-line {
            position: absolute;
            background: #00ff88;
        }
        
        .reticle-line.horizontal {
            width: 80px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        .reticle-line.vertical {
            width: 2px;
            height: 80px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Pontos AR */
        .ar-point {
            position: absolute;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 3px solid white;
            transform: translate(-50%, -50%);
            z-index: 30;
            pointer-events: auto;
            box-shadow: 0 0 20px currentColor;
            transition: all 0.3s ease;
        }
        
        .ar-point:hover {
            transform: translate(-50%, -50%) scale(1.2);
        }
        
        .point-number {
            position: absolute;
            top: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 14px;
            font-weight: bold;
            border: 2px solid white;
            white-space: nowrap;
            z-index: 40;
        }
        
        /* Linhas AR */
        .ar-line {
            position: absolute;
            height: 4px;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            transform-origin: 0 0;
            z-index: 25;
            pointer-events: none;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        
        .line-depth {
            position: absolute;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0, 255, 136, 0.1) 20%, 
                rgba(0, 255, 136, 0.3) 50%, 
                rgba(0, 255, 136, 0.1) 80%, 
                transparent 100%);
        }
        
        /* Labels de medida */
        .measure-label {
            position: absolute;
            background: rgba(0, 20, 10, 0.9);
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 16px;
            font-weight: bold;
            border: 2px solid #00ff88;
            z-index: 40;
            white-space: nowrap;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
            backdrop-filter: blur(10px);
        }
        
        /* Cabe√ßalho */
        .header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            padding: 20px 15px 15px;
            z-index: 100;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.6rem;
            background: linear-gradient(90deg, #00ff88, #00cc6a);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 0.9rem;
            opacity: 0.8;
        }
        
        /* Painel de controle */
        .control-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(to top, rgba(0,0,0,0.95), rgba(0,0,0,0.8));
            padding: 20px 15px;
            z-index: 100;
            backdrop-filter: blur(20px);
            border-top: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        /* Status info */
        .status-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 0.9rem;
            opacity: 0.9;
        }
        
        .status-item {
            background: rgba(0, 40, 20, 0.7);
            padding: 8px 15px;
            border-radius: 15px;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
        
        /* Display de medi√ß√£o */
        .measure-display {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .measure-card {
            background: rgba(0, 30, 15, 0.8);
            border-radius: 15px;
            padding: 15px 10px;
            text-align: center;
            border: 2px solid rgba(0, 255, 136, 0.3);
        }
        
        .measure-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #00ff88;
            line-height: 1;
        }
        
        .measure-unit {
            font-size: 0.8rem;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        /* Bot√µes de a√ß√£o */
        .action-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
        }
        
        .action-btn {
            padding: 16px 10px;
            border: none;
            border-radius: 15px;
            font-size: 1rem;
            font-weight: 600;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            transition: all 0.2s;
            user-select: none;
            background: rgba(0, 60, 30, 0.9);
            border: 2px solid rgba(0, 255, 136, 0.3);
        }
        
        .action-btn:active {
            transform: scale(0.95);
            background: rgba(0, 80, 40, 0.9);
        }
        
        .action-btn.active {
            background: #00ff88;
            color: #000;
            border-color: #00ff88;
        }
        
        .btn-icon {
            font-size: 1.5rem;
        }
        
        /* Modal de calibra√ß√£o */
        .calibration-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
            z-index: 1000;
            backdrop-filter: blur(20px);
        }
        
        .calibration-content {
            background: rgba(0, 30, 15, 0.95);
            border-radius: 25px;
            padding: 30px;
            text-align: center;
            max-width: 90%;
            border: 3px solid #00ff88;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
        }
        
        .calibration-title {
            font-size: 1.8rem;
            color: #00ff88;
            margin-bottom: 20px;
        }
        
        .calibration-steps {
            margin: 20px 0;
            text-align: left;
        }
        
        .calibration-step {
            margin-bottom: 15px;
            padding-left: 25px;
            position: relative;
        }
        
        .calibration-step::before {
            content: '‚Üí';
            position: absolute;
            left: 0;
            color: #00ff88;
        }
        
        .calibration-btn {
            background: #00ff88;
            color: #000;
            border: none;
            padding: 18px 40px;
            border-radius: 20px;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            width: 100%;
        }
        
        /* Indicador de movimento */
        .movement-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 200px;
            height: 200px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }
        
        .movement-dot {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff3366;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }
        
        .hidden {
            display: none !important;
        }
        
        /* Anima√ß√µes */
        @keyframes reticlePulse {
            0% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0.7); }
            70% { box-shadow: 0 0 0 20px rgba(0, 255, 136, 0); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 136, 0); }
        }
        
        @keyframes float {
            0%, 100% { transform: translate(-50%, -50%) translateY(0px); }
            50% { transform: translate(-50%, -50%) translateY(-10px); }
        }
        
        .floating {
            animation: float 3s ease-in-out infinite;
        }
        
        /* Debug panel */
        .debug-panel {
            position: absolute;
            top: 100px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
            display: none;
        }
        
        /* Depth visualization */
        .depth-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #3366ff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.5;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- C√¢mera -->
        <div class="camera-container">
            <video id="camera-view" autoplay playsinline></video>
        </div>
        
        <!-- Grade de profundidade -->
        <div class="depth-grid"></div>
        
        <!-- Overlay AR -->
        <div class="ar-overlay" id="ar-overlay">
            <!-- Pontos, linhas e labels ser√£o adicionados aqui -->
        </div>
        
        <!-- Reticulado AR -->
        <div class="ar-reticle">
            <div class="reticle-circle floating"></div>
            <div class="reticle-line horizontal"></div>
            <div class="reticle-line vertical"></div>
        </div>
        
        <!-- Indicador de movimento -->
        <div class="movement-indicator" id="movement-indicator"></div>
        
        <!-- Cabe√ßalho -->
        <div class="header">
            <h1>TRENA AR AVAN√áADA</h1>
            <p>Pontos fixos no espa√ßo real ‚Ä¢ Sensor de profundidade ‚Ä¢ C√°lculos 3D</p>
        </div>
        
        <!-- Painel de controle -->
        <div class="control-panel">
            <div class="status-info">
                <div class="status-item" id="status-gyro">üéØ Girosc√≥pio: Ativo</div>
                <div class="status-item" id="status-depth">üìê Profundidade: Simulado</div>
                <div class="status-item" id="status-points">üìç Pontos: 0</div>
            </div>
            
            <div class="measure-display">
                <div class="measure-card">
                    <div class="measure-value" id="distance-value">0.00</div>
                    <div class="measure-unit">DIST√ÇNCIA (m)</div>
                </div>
                <div class="measure-card">
                    <div class="measure-value" id="area-value">0.00</div>
                    <div class="measure-unit">√ÅREA (m¬≤)</div>
                </div>
                <div class="measure-card">
                    <div class="measure-value" id="volume-value">0.00</div>
                    <div class="measure-unit">VOLUME (m¬≥)</div>
                </div>
            </div>
            
            <div class="action-buttons">
                <button class="action-btn" id="btn-add-point">
                    <span class="btn-icon">üìç</span>
                    <span>Ponto</span>
                </button>
                <button class="action-btn" id="btn-calibrate">
                    <span class="btn-icon">üéØ</span>
                    <span>Calibrar</span>
                </button>
                <button class="action-btn" id="btn-switch-camera">
                    <span class="btn-icon">üì∑</span>
                    <span>C√¢mera</span>
                </button>
                <button class="action-btn" id="btn-clear">
                    <span class="btn-icon">üóëÔ∏è</span>
                    <span>Limpar</span>
                </button>
            </div>
        </div>
        
        <!-- Modal de calibra√ß√£o -->
        <div class="calibration-modal" id="calibration-modal">
            <div class="calibration-content">
                <div class="calibration-title">üéØ CALIBRA√á√ÉO DO SISTEMA</div>
                <p>Para medi√ß√µes precisas, calibre com um objeto de tamanho conhecido.</p>
                
                <div class="calibration-steps">
                    <div class="calibration-step">1. Coloque um objeto (ex: cart√£o) na cena</div>
                    <div class="calibration-step">2. Toque para adicionar pontos nas extremidades</div>
                    <div class="calibration-step">3. Digite o tamanho real do objeto</div>
                    <div class="calibration-step">4. O sistema calcular√° a escala automaticamente</div>
                </div>
                
                <div style="margin: 20px 0;">
                    <label style="display: block; margin-bottom: 10px;">Tamanho real do objeto (cm):</label>
                    <input type="number" id="calibration-size" value="10" min="1" max="100" 
                           style="width: 100%; padding: 15px; font-size: 1.2rem; border-radius: 15px; border: 2px solid #00ff88; background: rgba(0,0,0,0.5); color: white; text-align: center;">
                </div>
                
                <button class="calibration-btn" id="btn-start-calibration">INICIAR CALIBRA√á√ÉO</button>
                <button class="calibration-btn" style="background: #666; margin-top: 10px;" id="btn-skip-calibration">PULAR CALIBRA√á√ÉO</button>
            </div>
        </div>
        
        <!-- Debug panel (opcional) -->
        <div class="debug-panel" id="debug-panel">
            <div>Gyro X: <span id="debug-gyro-x">0</span></div>
            <div>Gyro Y: <span id="debug-gyro-y">0</span></div>
            <div>Gyro Z: <span id="debug-gyro-z">0</span></div>
            <div>Pontos: <span id="debug-points">0</span></div>
        </div>
    </div>

    <script>
        // ========== SISTEMA AVAN√áADO DE TRENA AR ==========
        
        // Elementos DOM
        const cameraView = document.getElementById('camera-view');
        const arOverlay = document.getElementById('ar-overlay');
        const calibrationModal = document.getElementById('calibration-modal');
        const debugPanel = document.getElementById('debug-panel');
        const movementIndicator = document.getElementById('movement-indicator');
        
        // Elementos de status
        const statusGyro = document.getElementById('status-gyro');
        const statusDepth = document.getElementById('status-depth');
        const statusPoints = document.getElementById('status-points');
        
        // Elementos de medida
        const distanceValue = document.getElementById('distance-value');
        const areaValue = document.getElementById('area-value');
        const volumeValue = document.getElementById('volume-value');
        
        // Bot√µes
        const btnAddPoint = document.getElementById('btn-add-point');
        const btnCalibrate = document.getElementById('btn-calibrate');
        const btnSwitchCamera = document.getElementById('btn-switch-camera');
        const btnClear = document.getElementById('btn-clear');
        const btnStartCalibration = document.getElementById('btn-start-calibration');
        const btnSkipCalibration = document.getElementById('btn-skip-calibration');
        const calibrationSizeInput = document.getElementById('calibration-size');
        
        // ========== SISTEMA DE ESTADO ==========
        const STATE = {
            cameraStream: null,
            isCameraActive: false,
            isFrontCamera: false,
            isCalibrated: false,
            scaleFactor: 0.01, // Fator de escala inicial (metros por pixel)
            calibrationDistance: null,
            
            // Sistema de pontos no espa√ßo 3D
            points: [], // Array de objetos Point3D
            lines: [],  // Linhas entre pontos
            labels: [], // Labels de medida
            
            // Sistema de tracking do dispositivo
            orientation: { alpha: 0, beta: 0, gamma: 0 },
            motion: { x: 0, y: 0, z: 0 },
            lastOrientation: null,
            
            // Sistema de profundidade
            depthMap: new Map(),
            isDepthEnabled: false,
            
            // Contadores
            pointCounter: 0,
            
            // Modos
            mode: 'add-point', // 'add-point', 'calibrate', 'measure'
            
            // Cache de elementos DOM
            domElements: new Map()
        };
        
        // ========== CLASSES DO SISTEMA ==========
        class Point3D {
            constructor(id, screenX, screenY, depth = 1) {
                this.id = id;
                this.screenX = screenX; // Posi√ß√£o na tela (0-100%)
                this.screenY = screenY;
                this.depth = depth;     // Profundidade estimada (1 = mais perto, 0 = mais longe)
                this.worldX = 0;        // Coordenadas 3D calculadas
                this.worldY = 0;
                this.worldZ = 0;
                this.orientation = { ...STATE.orientation }; // Orienta√ß√£o quando criado
                this.timestamp = Date.now();
                this.domElement = null;
                this.labelElement = null;
            }
            
            // Converter para coordenadas de mundo baseado na orienta√ß√£o atual
            updateWorldPosition(currentOrientation) {
                // Calcular diferen√ßa de orienta√ß√£o desde a cria√ß√£o
                const deltaAlpha = this.orientation.alpha - currentOrientation.alpha;
                const deltaBeta = this.orientation.beta - currentOrientation.beta;
                const deltaGamma = this.orientation.gamma - currentOrientation.gamma;
                
                // Converter para coordenadas 3D (simplificado)
                // Em um sistema real, usaria matrizes de rota√ß√£o
                const distanceFromCenter = this.depth * 5; // Fator de escala
                
                this.worldX = Math.sin(deltaAlpha * Math.PI / 180) * distanceFromCenter;
                this.worldY = Math.sin(deltaBeta * Math.PI / 180) * distanceFromCenter;
                this.worldZ = Math.cos(deltaGamma * Math.PI / 180) * distanceFromCenter;
                
                // Atualizar posi√ß√£o na tela baseado na orienta√ß√£o atual
                this.updateScreenPosition(currentOrientation);
            }
            
            updateScreenPosition(currentOrientation) {
                // Projetar coordenadas 3D de volta para a tela
                // Esta √© uma proje√ß√£o simplificada
                const fov = 60; // Campo de vis√£o aproximado
                const scale = 100 / (2 * Math.tan(fov * Math.PI / 360));
                
                const projectedX = 50 + (this.worldX * scale);
                const projectedY = 50 + (this.worldY * scale);
                
                // Garantir que fique dentro da tela
                this.screenX = Math.max(0, Math.min(100, projectedX));
                this.screenY = Math.max(0, Math.min(100, projectedY));
                
                // Atualizar elemento DOM se existir
                if (this.domElement) {
                    this.domElement.style.left = `${this.screenX}%`;
                    this.domElement.style.top = `${this.screenY}%`;
                    
                    // Ajustar cor baseado na profundidade
                    const depthColor = this.getDepthColor();
                    this.domElement.style.backgroundColor = depthColor;
                    this.domElement.style.boxShadow = `0 0 20px ${depthColor}`;
                }
            }
            
            getDepthColor() {
                // Verde (perto) -> Azul (longe)
                const green = Math.floor(255 * this.depth);
                const blue = Math.floor(255 * (1 - this.depth));
                return `rgb(0, ${green}, ${blue})`;
            }
        }
        
        // ========== INICIALIZA√á√ÉO ==========
        async function initializeSystem() {
            console.log("Inicializando sistema AR avan√ßado...");
            
            // Iniciar c√¢mera
            await startCamera();
            
            // Iniciar sensores do dispositivo
            initializeDeviceSensors();
            
            // Configurar listeners
            setupEventListeners();
            
            // Iniciar loop de anima√ß√£o
            requestAnimationFrame(updateARScene);
            
            // Mostrar modal de calibra√ß√£o
            setTimeout(() => {
                calibrationModal.classList.remove('hidden');
            }, 1000);
        }
        
        // ========== SISTEMA DE C√ÇMERA ==========
        async function startCamera() {
            try {
                const constraints = {
                    video: {
                        facingMode: STATE.isFrontCamera ? "user" : "environment",
                        width: { ideal: 1920 },
                        height: { ideal: 1080 }
                    }
                };
                
                STATE.cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
                cameraView.srcObject = STATE.cameraStream;
                STATE.isCameraActive = true;
                
                console.log("C√¢mera iniciada com sucesso");
                
            } catch (error) {
                console.error("Erro na c√¢mera:", error);
                alert("Erro ao acessar a c√¢mera. Verifique as permiss√µes.");
            }
        }
        
        async function switchCamera() {
            if (!STATE.cameraStream) return;
            
            STATE.cameraStream.getTracks().forEach(track => track.stop());
            STATE.isFrontCamera = !STATE.isFrontCamera;
            
            await startCamera();
            
            // Atualizar status
            statusGyro.textContent = `üì∑ C√¢mera: ${STATE.isFrontCamera ? 'Frontal' : 'Traseira'}`;
        }
        
        // ========== SISTEMA DE SENSORES ==========
        function initializeDeviceSensors() {
            // Girosc√≥pio e Aceler√¥metro
            if (window.DeviceOrientationEvent) {
                window.addEventListener('deviceorientation', handleOrientation);
                statusGyro.textContent = "üéØ Girosc√≥pio: Ativo";
            } else {
                statusGyro.textContent = "üéØ Girosc√≥pio: N√£o suportado";
                console.warn("DeviceOrientation n√£o suportado");
            }
            
            if (window.DeviceMotionEvent) {
                window.addEventListener('devicemotion', handleMotion);
            }
            
            // Estimativa de profundidade usando movimento parallax
            STATE.isDepthEnabled = true;
            statusDepth.textContent = "üìê Profundidade: Ativo";
        }
        
        function handleOrientation(event) {
            // Salvar orienta√ß√£o atual
            STATE.orientation = {
                alpha: event.alpha || 0,
                beta: event.beta || 0,
                gamma: event.gamma || 0
            };
            
            // Atualizar debug
            document.getElementById('debug-gyro-x').textContent = STATE.orientation.beta.toFixed(1);
            document.getElementById('debug-gyro-y').textContent = STATE.orientation.gamma.toFixed(1);
            document.getElementById('debug-gyro-z').textContent = STATE.orientation.alpha.toFixed(1);
        }
        
        function handleMotion(event) {
            if (event.accelerationIncludingGravity) {
                STATE.motion = {
                    x: event.accelerationIncludingGravity.x || 0,
                    y: event.accelerationIncludingGravity.y || 0,
                    z: event.accelerationIncludingGravity.z || 0
                };
            }
        }
        
        // ========== SISTEMA DE PONTOS AR ==========
        function addARPoint() {
            if (!STATE.isCameraActive) {
                alert("Ative a c√¢mera primeiro!");
                return;
            }
            
            STATE.pointCounter++;
            
            // Criar ponto na posi√ß√£o central da tela
            const point = new Point3D(
                STATE.pointCounter,
                50, // Centro X
                50, // Centro Y
                estimateDepth() // Estimar profundidade
            );
            
            // Adicionar ao estado
            STATE.points.push(point);
            
            // Criar elementos visuais
            createPointElement(point);
            
            // Atualizar interface
            updateStatusDisplay();
            
            // Se tiver pelo menos 2 pontos, criar linhas e calcular
            if (STATE.points.length >= 2) {
                updateMeasurements();
            }
            
            // Feedback visual
            btnAddPoint.classList.add('active');
            setTimeout(() => btnAddPoint.classList.remove('active'), 300);
        }
        
        function estimateDepth() {
            // Estimativa simplificada de profundidade baseada em:
            // 1. N√∫mero de pontos existentes
            // 2. Movimento do dispositivo
            // 3. Posi√ß√£o na tela
            
            let depth = 0.5; // Valor padr√£o
            
            // Se houver pontos anteriores, estimar baseado na dist√¢ncia aparente
            if (STATE.points.length > 0) {
                const lastPoint = STATE.points[STATE.points.length - 1];
                // Pequena varia√ß√£o aleat√≥ria para simular diferentes profundidades
                depth = Math.max(0.1, Math.min(1, lastPoint.depth + (Math.random() * 0.2 - 0.1)));
            }
            
            // Ajustar baseado na orienta√ß√£o (objetos mais altos na tela = mais longe)
            depth = Math.max(0.2, Math.min(0.8, depth));
            
            return depth;
        }
        
        function createPointElement(point) {
            // Criar elemento do ponto
            const pointElement = document.createElement('div');
            pointElement.className = 'ar-point floating';
            pointElement.style.left = `${point.screenX}%`;
            pointElement.style.top = `${point.screenY}%`;
            pointElement.style.backgroundColor = point.getDepthColor();
            
            // N√∫mero do ponto
            const numberElement = document.createElement('div');
            numberElement.className = 'point-number';
            numberElement.textContent = point.id;
            pointElement.appendChild(numberElement);
            
            // Adicionar ao overlay
            arOverlay.appendChild(pointElement);
            point.domElement = pointElement;
            
            // Armazenar refer√™ncia
            STATE.domElements.set(`point-${point.id}`, pointElement);
        }
        
        // ========== SISTEMA DE MEDI√á√ÉO AVAN√áADO ==========
        function updateMeasurements() {
            if (STATE.points.length < 2) return;
            
            // Calcular dist√¢ncias entre pontos consecutivos
            let totalDistance = 0;
            let latestDistance = 0;
            
            for (let i = 1; i < STATE.points.length; i++) {
                const pointA = STATE.points[i-1];
                const pointB = STATE.points[i];
                
                // Atualizar posi√ß√µes 3D
                pointA.updateWorldPosition(STATE.orientation);
                pointB.updateWorldPosition(STATE.orientation);
                
                // Calcular dist√¢ncia 3D
                const dx = pointB.worldX - pointA.worldX;
                const dy = pointB.worldY - pointA.worldY;
                const dz = pointB.worldZ - pointA.worldZ;
                const distance3D = Math.sqrt(dx*dx + dy*dy + dz*dz);
                
                // Aplicar fator de escala
                const realDistance = distance3D * STATE.scaleFactor;
                
                totalDistance += realDistance;
                
                if (i === STATE.points.length - 1) {
                    latestDistance = realDistance;
                    
                    // Criar/atualizar linha entre os √∫ltimos pontos
                    createLineBetweenPoints(pointA, pointB, realDistance);
                }
            }
            
            // Atualizar displays
            distanceValue.textContent = latestDistance.toFixed(2);
            
            // Calcular √°rea se tiver pelo menos 3 pontos
            if (STATE.points.length >= 3) {
                calculateArea3D();
            }
            
            // Calcular volume se tiver pelo menos 4 pontos
            if (STATE.points.length >= 4) {
                calculateVolume3D();
            }
        }
        
        function createLineBetweenPoints(pointA, pointB, distance) {
            const lineId = `line-${pointA.id}-${pointB.id}`;
            
            // Remover linha existente
            const existingLine = STATE.domElements.get(lineId);
            if (existingLine) {
                existingLine.remove();
                STATE.domElements.delete(lineId);
            }
            
            // Remover label existente
            const existingLabel = STATE.domElements.get(`${lineId}-label`);
            if (existingLabel) {
                existingLabel.remove();
                STATE.domElements.delete(`${lineId}-label`);
            }
            
            // Calcular √¢ngulo e dist√¢ncia na tela
            const dx = pointB.screenX - pointA.screenX;
            const dy = pointB.screenY - pointA.screenY;
            const screenDistance = Math.sqrt(dx*dx + dy*dy);
            const angle = Math.atan2(dy, dx) * (180 / Math.PI);
            
            // Criar linha
            const lineElement = document.createElement('div');
            lineElement.className = 'ar-line';
            lineElement.style.left = `${pointA.screenX}%`;
            lineElement.style.top = `${pointA.screenY}%`;
            lineElement.style.width = `${screenDistance}%`;
            lineElement.style.transform = `rotate(${angle}deg)`;
            
            // Efeito de profundidade
            const depthEffect = document.createElement('div');
            depthEffect.className = 'line-depth';
            lineElement.appendChild(depthEffect);
            
            arOverlay.appendChild(lineElement);
            STATE.domElements.set(lineId, lineElement);
            
            // Criar label
            const midX = (pointA.screenX + pointB.screenX) / 2;
            const midY = (pointA.screenY + pointB.screenY) / 2;
            
            const labelElement = document.createElement('div');
            labelElement.className = 'measure-label';
            labelElement.textContent = `${distance.toFixed(2)} m`;
            labelElement.style.left = `${midX}%`;
            labelElement.style.top = `${midY}%`;
            labelElement.style.transform = `translate(-50%, -50%) rotate(${-angle}deg)`;
            
            arOverlay.appendChild(labelElement);
            STATE.domElements.set(`${lineId}-label`, labelElement);
        }
        
        function calculateArea3D() {
            // F√≥rmula de √°rea para pol√≠gono 3D
            let area = 0;
            
            for (let i = 0; i < STATE.points.length; i++) {
                const j = (i + 1) % STATE.points.length;
                const pointA = STATE.points[i];
                const pointB = STATE.points[j];
                
                // Usar coordenadas 3D para c√°lculo mais preciso
                area += pointA.worldX * pointB.worldY - pointB.worldX * pointA.worldY;
            }
            
            area = Math.abs(area / 2) * STATE.scaleFactor * STATE.scaleFactor;
            areaValue.textContent = area.toFixed(2);
        }
        
        function calculateVolume3D() {
            // Para 4 pontos, assumir paralelep√≠pedo
            if (STATE.points.length >= 4) {
                // Calcular vetores
                const p0 = STATE.points[0];
                const p1 = STATE.points[1];
                const p2 = STATE.points[2];
                const p3 = STATE.points[3];
                
                const v1 = { 
                    x: p1.worldX - p0.worldX, 
                    y: p1.worldY - p0.worldY, 
                    z: p1.worldZ - p0.worldZ 
                };
                
                const v2 = { 
                    x: p2.worldX - p0.worldX, 
                    y: p2.worldY - p0.worldY, 
                    z: p2.worldZ - p0.worldZ 
                };
                
                const v3 = { 
                    x: p3.worldX - p0.worldX, 
                    y: p3.worldY - p0.worldY, 
                    z: p3.worldZ - p0.worldZ 
                };
                
                // Produto misto (volume do paralelep√≠pedo)
                const scalarTriple = 
                    v1.x * (v2.y * v3.z - v2.z * v3.y) -
                    v1.y * (v2.x * v3.z - v2.z * v3.x) +
                    v1.z * (v2.x * v3.y - v2.y * v3.x);
                
                const volume = Math.abs(scalarTriple) * 
                              Math.pow(STATE.scaleFactor, 3);
                
                volumeValue.textContent = volume.toFixed(3);
            }
        }
        
        // ========== SISTEMA DE CALIBRA√á√ÉO ==========
        function startCalibration() {
            const realSize = parseFloat(calibrationSizeInput.value) / 100; // Converter cm para m
            
            if (STATE.points.length >= 2) {
                // Usar os dois √∫ltimos pontos para calibra√ß√£o
                const pointA = STATE.points[STATE.points.length - 2];
                const pointB = STATE.points[STATE.points.length - 1];
                
                // Calcular dist√¢ncia na tela
                const dx = pointB.screenX - pointA.screenX;
                const dy = pointB.screenY - pointA.screenY;
                const screenDistance = Math.sqrt(dx*dx + dy*dy);
                
                // Calcular novo fator de escala
                STATE.scaleFactor = realSize / screenDistance;
                STATE.isCalibrated = true;
                
                alert(`Calibra√ß√£o conclu√≠da! Escala: ${STATE.scaleFactor.toFixed(6)} m/px`);
                calibrationModal.classList.add('hidden');
                
                // Recalcular todas as medi√ß√µes
                updateMeasurements();
            } else {
                alert("Adicione pelo menos 2 pontos para calibrar!");
            }
        }
        
        // ========== ATUALIZA√á√ÉO DA CENA AR ==========
        function updateARScene() {
            // Atualizar posi√ß√£o de todos os pontos baseado na orienta√ß√£o atual
            STATE.points.forEach(point => {
                point.updateWorldPosition(STATE.orientation);
            });
            
            // Atualizar linhas
            updateAllLines();
            
            // Atualizar movimento indicator
            updateMovementIndicator();
            
            // Atualizar contador de pontos no debug
            document.getElementById('debug-points').textContent = STATE.points.length;
            
            // Pr√≥ximo frame
            requestAnimationFrame(updateARScene);
        }
        
        function updateAllLines() {
            // Atualizar todas as linhas entre pontos consecutivos
            for (let i = 1; i < STATE.points.length; i++) {
                const pointA = STATE.points[i-1];
                const pointB = STATE.points[i];
                
                const lineId = `line-${pointA.id}-${pointB.id}`;
                const lineElement = STATE.domElements.get(lineId);
                
                if (lineElement) {
                    const dx = pointB.screenX - pointA.screenX;
                    const dy = pointB.screenY - pointA.screenY;
                    const screenDistance = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) * (180 / Math.PI);
                    
                    lineElement.style.left = `${pointA.screenX}%`;
                    lineElement.style.top = `${pointA.screenY}%`;
                    lineElement.style.width = `${screenDistance}%`;
                    lineElement.style.transform = `rotate(${angle}deg)`;
                }
            }
        }
        
        function updateMovementIndicator() {
            // Mostrar pontos de movimento baseado no girosc√≥pio
            movementIndicator.innerHTML = '';
            
            const numDots = 5;
            for (let i = 0; i < numDots; i++) {
                const dot = document.createElement('div');
                dot.className = 'movement-dot';
                
                // Posicionar baseado na orienta√ß√£o
                const angle = (STATE.orientation.alpha + (i * 72)) * Math.PI / 180;
                const radius = 50 + Math.sin(Date.now() / 1000 + i) * 30;
                
                const x = 50 + radius * Math.cos(angle);
                const y = 50 + radius * Math.sin(angle);
                
                dot.style.left = `${x}%`;
                dot.style.top = `${y}%`;
                
                movementIndicator.appendChild(dot);
            }
        }
        
        // ========== FUN√á√ïES DE UTILIDADE ==========
        function clearAllMeasurements() {
            // Remover todos os elementos DOM
            STATE.domElements.forEach(element => {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
            });
            
            // Limpar estado
            STATE.domElements.clear();
            STATE.points = [];
            STATE.lines = [];
            STATE.labels = [];
            STATE.pointCounter = 0;
            
            // Limpar displays
            distanceValue.textContent = '0.00';
            areaValue.textContent = '0.00';
            volumeValue.textContent = '0.00';
            
            updateStatusDisplay();
        }
        
        function updateStatusDisplay() {
            statusPoints.textContent = `üìç Pontos: ${STATE.points.length}`;
            
            if (STATE.isCalibrated) {
                statusDepth.textContent = `üìê Calibrado: ${STATE.scaleFactor.toFixed(4)} m/px`;
            }
        }
        
        // ========== EVENT LISTENERS ==========
        function setupEventListeners() {
            // Bot√µes principais
            btnAddPoint.addEventListener('click', addARPoint);
            btnCalibrate.addEventListener('click', () => {
                calibrationModal.classList.remove('hidden');
            });
            btnSwitchCamera.addEventListener('click', switchCamera);
            btnClear.addEventListener('click', clearAllMeasurements);
            
            // Calibra√ß√£o
            btnStartCalibration.addEventListener('click', startCalibration);
            btnSkipCalibration.addEventListener('click', () => {
                calibrationModal.classList.add('hidden');
                alert("Usando escala padr√£o. Para medi√ß√µes precisas, recomenda-se calibrar.");
            });
            
            // Toque na tela para adicionar ponto
            arOverlay.addEventListener('click', (e) => {
                if (STATE.mode === 'add-point') {
                    // Calcular posi√ß√£o do clique
                    const rect = arOverlay.getBoundingClientRect();
                    const x = ((e.clientX - rect.left) / rect.width) * 100;
                    const y = ((e.clientY - rect.top) / rect.height) * 100;
                    
                    // Adicionar ponto na posi√ß√£o clicada
                    addPointAtPosition(x, y);
                }
            });
            
            // Tecla D para debug
            document.addEventListener('keydown', (e) => {
                if (e.key === 'd' || e.key === 'D') {
                    debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
                }
            });
        }
        
        function addPointAtPosition(x, y) {
            STATE.pointCounter++;
            
            const point = new Point3D(
                STATE.pointCounter,
                x,
                y,
                estimateDepth()
            );
            
            STATE.points.push(point);
            createPointElement(point);
            updateStatusDisplay();
            
            if (STATE.points.length >= 2) {
                updateMeasurements();
            }
        }
        
        // ========== INICIALIZAR APLICA√á√ÉO ==========
        window.addEventListener('DOMContentLoaded', initializeSystem);
        
        // Gerenciar visibilidade da p√°gina
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && STATE.cameraStream) {
                STATE.cameraStream.getTracks().forEach(track => track.pause());
            } else if (!document.hidden && STATE.cameraStream) {
                STATE.cameraStream.getTracks().forEach(track => track.resume());
            }
        });
    </script>
</body>
</html>
